from typing import TYPE_CHECKING, Optional

import sqlalchemy
from alembic import autogenerate
from alembic.autogenerate import api
from alembic.operations import ops
from sqlalchemy import MetaData, Table, Column, Integer
from sqlalchemy.dialects import postgresql
from alembic_postgresql_enum.add_create_type_false import ReprWorkaround
from alembic_postgresql_enum.operations import CreateEnumOp
from tests.base.run_migration_test_abc import CompareAndRunTestCase
from tests.schemas import (
    get_schema_without_enum,
    USER_TABLE_NAME,
    USER_STATUS_ENUM_NAME,
    USER_STATUS_COLUMN_NAME,
    DEFAULT_SCHEMA,
)
from tests.utils.migration_context import create_migration_context

if TYPE_CHECKING:
    from sqlalchemy import Connection

class EnumType(ReprWorkaround):
    pass

class TestScalarCoercibleInheritance(CompareAndRunTestCase):
    """
    Test that verifies the behavior when a class inherits from both
    ScalarCoercible and ReprWorkaround.
    """
    new_enum_variants = ["active", "passive"]

    def get_database_schema(self) -> MetaData:
        return get_schema_without_enum()

    def get_target_schema(self) -> MetaData:
        target_schema = MetaData()

        Table(
            USER_TABLE_NAME,
            target_schema,
            Column("id", Integer, primary_key=True),
            Column(
                USER_STATUS_COLUMN_NAME,
                EnumType(*self.new_enum_variants, name=USER_STATUS_ENUM_NAME),
            ),
        )

        return target_schema

    def get_expected_upgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        sa.Enum({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}').create(op.get_bind())
        op.add_column('{USER_TABLE_NAME}', sa.Column('{USER_STATUS_COLUMN_NAME}', postgresql.ENUM({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}', create_type=False), nullable=True))
        # ### end Alembic commands ###
        """

    def get_expected_downgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        op.drop_column('{USER_TABLE_NAME}', '{USER_STATUS_COLUMN_NAME}')
        sa.Enum({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}').drop(op.get_bind())
        # ### end Alembic commands ###
        """

def test_scalar_coercible_inheritance_diff_tuple(connection: "Connection"):
    """
    Check that library correctly handles EnumType that inherits from both
    ScalarCoercible and ReprWorkaround.
    """
    database_schema = get_schema_without_enum()
    database_schema.create_all(connection)

    new_enum_variants = ["active", "passive"]

    target_schema = MetaData()

    Table(
        USER_TABLE_NAME,
        target_schema,
        Column("id", Integer, primary_key=True),
        Column(
            USER_STATUS_COLUMN_NAME,
            EnumType(*new_enum_variants, name=USER_STATUS_ENUM_NAME),
        ),
    )

    context = create_migration_context(connection, target_schema)

    autogen_context = api.AutogenContext(context, target_schema)
    autogen_context.imports.add("from tests.test_enum_creation.test_scalar_coercible_inheritance import EnumType")

    uo = ops.UpgradeOps(ops=[])
    autogenerate._produce_net_changes(autogen_context, uo)


    diffs = uo.as_diffs()
    print(diffs)
    create_enum_tuple, add_column_tuple = diffs
    print("CREATE ENUM TUPLE: ", create_enum_tuple)
    print("ADD COLUMN TUPLE: ", add_column_tuple)
    assert len(diffs) == 2
    assert create_enum_tuple == (
        CreateEnumOp.operation_name,
        USER_STATUS_ENUM_NAME,
        DEFAULT_SCHEMA,
        tuple(new_enum_variants),
    )
    assert add_column_tuple[0] == "add_column"