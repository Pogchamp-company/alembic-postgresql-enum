from typing import TYPE_CHECKING

import sqlalchemy
from alembic import autogenerate
from alembic.autogenerate import api
from alembic.operations import ops

from alembic_postgresql_enum.operations import CreateEnumOp
from tests.base.run_migration_test_abc import CompareAndRunTestCase
from tests.schemas import (
    get_schema_with_enum_variants,
    USER_TABLE_NAME,
    USER_STATUS_ENUM_NAME,
    get_schema_without_enum,
    USER_STATUS_COLUMN_NAME,
    DEFAULT_SCHEMA,
    CAR_COLORS_ENUM_NAME,
    get_schema_with_enum_in_array_variants,
    get_car_schema_without_enum,
)
from tests.utils.migration_context import create_migration_context

if TYPE_CHECKING:
    from sqlalchemy import Connection
from sqlalchemy import MetaData, Table, Column, Integer


class TestCreateEnumBeforeAddColumn(CompareAndRunTestCase):
    new_enum_variants = ["active", "passive"]

    def get_database_schema(self) -> MetaData:
        return get_schema_without_enum()

    def get_target_schema(self) -> MetaData:
        return get_schema_with_enum_variants(self.new_enum_variants)

    def get_expected_upgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        sa.Enum({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}').create(op.get_bind())
        op.add_column('{USER_TABLE_NAME}', sa.Column('{USER_STATUS_COLUMN_NAME}', postgresql.ENUM({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}', create_type=False), nullable=True))
        # ### end Alembic commands ###
        """

    def get_expected_downgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        op.drop_column('{USER_TABLE_NAME}', '{USER_STATUS_COLUMN_NAME}')
        sa.Enum({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}').drop(op.get_bind())
        # ### end Alembic commands ###
        """


class TestCreateEnumBeforeAddColumn(CompareAndRunTestCase):
    """Check that library correctly creates enum before its use inside add_column"""

    new_enum_variants = ["active", "passive"]

    def get_database_schema(self) -> MetaData:
        return get_schema_without_enum()

    def get_target_schema(self) -> MetaData:
        return get_schema_with_enum_variants(self.new_enum_variants)

    def get_expected_upgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        sa.Enum({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}').create(op.get_bind())
        op.add_column('{USER_TABLE_NAME}', sa.Column('{USER_STATUS_COLUMN_NAME}', postgresql.ENUM({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}', create_type=False), nullable=True))
        # ### end Alembic commands ###
        """

    def get_expected_downgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        op.drop_column('{USER_TABLE_NAME}', '{USER_STATUS_COLUMN_NAME}')
        sa.Enum({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}').drop(op.get_bind())
        # ### end Alembic commands ###
        """


def test_create_enum_diff_tuple(connection: "Connection"):
    """Check that library correctly creates enum before its use inside add_column"""
    database_schema = get_schema_without_enum()
    database_schema.create_all(connection)

    new_enum_variants = ["active", "passive"]

    target_schema = get_schema_with_enum_variants(new_enum_variants)

    context = create_migration_context(connection, target_schema)

    autogen_context = api.AutogenContext(context, target_schema)

    uo = ops.UpgradeOps(ops=[])
    autogenerate._produce_net_changes(autogen_context, uo)

    diffs = uo.as_diffs()
    assert len(diffs) == 2
    create_enum_tuple, add_column_tuple = diffs

    assert create_enum_tuple == (
        CreateEnumOp.operation_name,
        USER_STATUS_ENUM_NAME,
        DEFAULT_SCHEMA,
        tuple(new_enum_variants),
    )
    assert add_column_tuple[0] == "add_column"


def test_create_enum_diff_tuple_with_array(connection: "Connection"):
    """Check that library correctly creates enum before its use inside add_column"""
    database_schema = get_car_schema_without_enum()
    database_schema.create_all(connection)

    new_enum_variants = ["black", "white", "red", "green", "blue", "other"]

    target_schema = get_schema_with_enum_in_array_variants(new_enum_variants)

    context = create_migration_context(connection, target_schema)

    autogen_context = api.AutogenContext(context, target_schema)

    uo = ops.UpgradeOps(ops=[])
    autogenerate._produce_net_changes(autogen_context, uo)

    diffs = uo.as_diffs()
    assert len(diffs) == 2
    create_enum_tuple, add_column_tuple = diffs

    assert create_enum_tuple == (
        CreateEnumOp.operation_name,
        CAR_COLORS_ENUM_NAME,
        DEFAULT_SCHEMA,
        tuple(new_enum_variants),
    )
    assert add_column_tuple[0] == "add_column"


class TestWithNonNativeEnum(CompareAndRunTestCase):
    """Check that library ignores sa.Enum that are not native"""

    new_enum_variants = ["active", "passive"]

    def get_database_schema(self) -> MetaData:
        return get_schema_without_enum()

    def get_target_schema(self) -> MetaData:
        target_schema = MetaData()

        Table(
            USER_TABLE_NAME,
            target_schema,
            Column("id", Integer, primary_key=True),
            Column(
                USER_STATUS_COLUMN_NAME,
                sqlalchemy.Enum(*self.new_enum_variants, name=USER_STATUS_ENUM_NAME, native_enum=False),
            ),
        )

        return target_schema

    def get_expected_upgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        op.add_column('{USER_TABLE_NAME}', sa.Column('{USER_STATUS_COLUMN_NAME}', sa.Enum({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}', native_enum=False), nullable=True))
        # ### end Alembic commands ###
        """

    def get_expected_downgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        op.drop_column('{USER_TABLE_NAME}', '{USER_STATUS_COLUMN_NAME}')
        # ### end Alembic commands ###
        """


class TestCreateEnumBeforeAddColumnMetadataList(CompareAndRunTestCase):
    """Check that library correctly creates enum before its use inside add_column when metadata is in list"""

    new_enum_variants = ["active", "passive"]

    def get_database_schema(self) -> MetaData:
        return get_schema_without_enum()

    def get_target_schema(self) -> MetaData:
        return get_schema_with_enum_variants(self.new_enum_variants)

    def get_expected_upgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        sa.Enum({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}').create(op.get_bind())
        op.add_column('{USER_TABLE_NAME}', sa.Column('{USER_STATUS_COLUMN_NAME}', postgresql.ENUM({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}', create_type=False), nullable=True))
        # ### end Alembic commands ###
        """

    def get_expected_downgrade(self) -> str:
        return f"""
        # ### commands auto generated by Alembic - please adjust! ###
        op.drop_column('{USER_TABLE_NAME}', '{USER_STATUS_COLUMN_NAME}')
        sa.Enum({', '.join(map(repr, self.new_enum_variants))}, name='{USER_STATUS_ENUM_NAME}').drop(op.get_bind())
        # ### end Alembic commands ###
        """
